"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/out.ts
var _shelljs = require('shelljs'); var shell = _interopRequireWildcard(_shelljs);
var _chalk = require('chalk'); var _chalk2 = _interopRequireDefault(_chalk);
var _lodash = require('lodash');

// src/const.ts
var __cwd = process.cwd();
var _a, _b;
var __columns = (_b = (_a = process == null ? void 0 : process.stdout) == null ? void 0 : _a.columns) != null ? _b : 120;
var ImageFail = 1;
var DocFail = 2;

// src/out.ts
var _process = require('process'); var process2 = _interopRequireWildcard(_process);
function println(level, head, content) {
  const color = {
    [0 /* ACCESS */]: _chalk2.default.blue,
    [1 /* INFO */]: _chalk2.default.green,
    [2 /* WARNING */]: _chalk2.default.yellow,
    [3 /* ERROR */]: _chalk2.default.red,
    [4 /* DEBUG */]: _chalk2.default.magenta
  };
  if (typeof head === "object" && !content) {
    try {
      head = JSON.stringify(head);
    } catch (e) {
      console.log(head);
      return;
    }
    shell.echo(color[level](head));
  }
  if (!head) {
    if (!content) {
      return;
    }
    head = content;
  }
  const MIN_HEAD_LENGTH = 10;
  const emptyHead = head.replace(/[\u4e00-\u9fa5]/g, "aa");
  const headLength = Math.max(emptyHead.length + 2, MIN_HEAD_LENGTH);
  const fillLength = Math.max(MIN_HEAD_LENGTH - emptyHead.length, 0);
  if (!content) {
    shell.echo(color[level](head));
    return;
  }
  if (content && typeof content !== "string") {
    shell.echo(color[level](head));
    shell.echo(content);
    return;
  }
  ;
  (content != null ? content : "").replace("/\r\n/g", "\n").split("\n").map((c) => _lodash.chunk.call(void 0, c, __columns - headLength).map((str) => str.join(""))).reduce((r, c) => r.concat(c)).forEach((str, i) => {
    const _head = i ? " ".repeat(headLength) : color[level](`${head}${" ".repeat(fillLength)}`);
    shell.echo(_head + str);
  });
}
var out = {
  access(head, content) {
    println(0 /* ACCESS */, head, content);
  },
  info(head, content) {
    println(1 /* INFO */, head, content);
  },
  warning(head, content) {
    println(2 /* WARNING */, head, content);
  },
  err(head, content) {
    println(3 /* ERROR */, head, content);
  },
  debug(head, content) {
    process2.env.DEBUG && println(4 /* DEBUG */, head, content);
  }
};
var out_default = out;

// src/request.ts
var _urllib = require('urllib');
var request = (url, reqOpts) => __async(void 0, null, function* () {
  var _a2;
  const opts = __spreadValues({
    contentType: "json",
    dataType: "json",
    headers: __spreadValues({
      "User-Agent": "Elog"
    }, reqOpts == null ? void 0 : reqOpts.headers),
    gzip: true,
    // 超时时间 60s
    timeout: Number(((_a2 = process.env) == null ? void 0 : _a2.REQUEST_TIMEOUT) || 6e4) || 6e4
  }, reqOpts);
  out_default.debug(`API\u8BF7\u6C42URL: ${url}`);
  if (url.includes("api.github.com")) {
    out_default.debug(`API\u8BF7\u6C42Header\u53C2\u6570: ${JSON.stringify((reqOpts == null ? void 0 : reqOpts.headers) || {})}`);
  } else {
    out_default.debug(`API\u8BF7\u6C42\u53C2\u6570: ${JSON.stringify(opts)}`);
  }
  return _urllib.request.call(void 0, url, opts);
});
function delay(ms = 500) {
  return __async(this, null, function* () {
    yield new Promise((resolve) => setTimeout(resolve, ms));
  });
}

// src/index.ts


// src/utils/image.ts
var _imagesize = require('image-size'); var _imagesize2 = _interopRequireDefault(_imagesize);

// src/utils/qetag.js
function getEtag(buffer, callback) {
  let mode = "buffer";
  if (typeof buffer === "string") {
    buffer = __require("fs").createReadStream(buffer);
    mode = "stream";
  } else if (buffer instanceof __require("stream")) {
    mode = "stream";
  }
  const sha1 = function(content) {
    const crypto = __require("crypto");
    const sha12 = crypto.createHash("sha1");
    sha12.update(content);
    return sha12.digest();
  };
  const blockSize = 4 * 1024 * 1024;
  const sha1String = [];
  let prefix = 22;
  let blockCount = 0;
  switch (mode) {
    case "buffer":
      const bufferSize = buffer.length;
      blockCount = Math.ceil(bufferSize / blockSize);
      for (let i = 0; i < blockCount; i++) {
        sha1String.push(sha1(buffer.slice(i * blockSize, (i + 1) * blockSize)));
      }
      process.nextTick(function() {
        callback(calcEtag());
      });
      break;
    case "stream":
      const stream = buffer;
      stream.on("readable", function() {
        let chunk2;
        while (chunk2 = stream.read(blockSize)) {
          sha1String.push(sha1(chunk2));
          blockCount++;
        }
      });
      stream.on("end", function() {
        callback(calcEtag());
      });
      break;
  }
  function calcEtag() {
    if (!sha1String.length) {
      return "Fto5o-5ea0sNMlW_75VgGJCv2AcJ";
    }
    let sha1Buffer = Buffer.concat(sha1String, blockCount * 20);
    if (blockCount > 1) {
      prefix = 150;
      sha1Buffer = sha1(sha1Buffer);
    }
    sha1Buffer = Buffer.concat([Buffer.from([prefix]), sha1Buffer], sha1Buffer.length + 1);
    return sha1Buffer.toString("base64").replace(/\//g, "_").replace(/\+/g, "-");
  }
}

// src/utils/image.ts
var _crypto = require('crypto');
var getFileTypeFromUrl = (url, needError = true) => {
  var _a2;
  const reg = /[^/]+(?!.*\/)/g;
  const imgName = (_a2 = url.match(reg)) == null ? void 0 : _a2.filter((item) => item).pop();
  let filename = "";
  let filetype = "";
  if (imgName) {
    const imgL = imgName.split(".");
    if (imgL.length > 1) {
      filename = imgName.split(".")[0];
      filetype = imgName.split(".")[1].split("?")[0].split("#")[0];
      return {
        name: filename,
        type: filetype
      };
    } else {
      needError && out_default.warning(`\u83B7\u53D6\u6587\u4EF6\u540D\u5931\u8D25\uFF0C\u8DF3\u8FC7: ${url}`);
    }
  } else {
    needError && out_default.warning(`\u83B7\u53D6\u6587\u4EF6\u540D\u5931\u8D25\uFF0C\u8DF3\u8FC7: ${url}`);
  }
};
var getFileTypeFromBuffer = (buffer) => {
  const fileType = _imagesize2.default.call(void 0, buffer).type;
  if (fileType) {
    return {
      type: fileType
    };
  }
};
var getFileType = (url) => __async(void 0, null, function* () {
  let fileType = getFileTypeFromUrl(url, false);
  if (!fileType) {
    const buffer = yield getPicBufferFromURL(url);
    if (buffer) {
      fileType = getFileTypeFromBuffer(buffer);
      return fileType;
    }
  }
  return fileType;
});
function getFileName(imgBuffer) {
  return __async(this, null, function* () {
    return new Promise((resolve) => {
      getEtag(imgBuffer, (hash) => {
        resolve(hash);
      });
    });
  });
}
var cleanParameter = (originalUrl) => {
  let newUrl = originalUrl;
  const indexPoundSign = originalUrl.indexOf("#");
  if (indexPoundSign !== -1) {
    newUrl = originalUrl.substring(0, indexPoundSign);
  }
  const indexQuestionMark = originalUrl.indexOf("?");
  if (indexQuestionMark !== -1) {
    newUrl = originalUrl.substring(0, indexQuestionMark);
  }
  return newUrl;
};
var getUrlListFromContent = (content) => {
  const markdownURLList = (content.match(/!\[[^\]]*\]\(([^)]+)\)/g) || []).map((item) => {
    const res = item.match(/\!\[.*\]\((.*?)( ".*")?\)/);
    if (res) {
      const url = res[1];
      if (url.startsWith("data:"))
        return void 0;
      return {
        original: url,
        url: cleanParameter(url)
      };
    }
    return void 0;
  }).filter((item) => item);
  const imageTagURLList = (content.match(/<img.*?(?:>|\/>)/gi) || []).map((item) => {
    const res = item.match(/src=[\'\"]?([^\'\"]*)[\'\"]?/i);
    if (res) {
      const url = res[1];
      if (url.startsWith("data:"))
        return void 0;
      return {
        original: url,
        url: cleanParameter(url)
      };
    }
    return void 0;
  }).filter((item) => item);
  return markdownURLList.concat(imageTagURLList);
};
var getUrl = (url) => {
  return {
    original: url,
    url: cleanParameter(url)
  };
};
var generateUniqueId = (url, length) => {
  const hash = _crypto.createHash.call(void 0, "md5").update(url).digest("hex");
  if (length) {
    return hash.substring(0, length);
  }
  return hash;
};
var getPicBufferFromURL = (url) => __async(void 0, null, function* () {
  try {
    let referer = "";
    if (url.includes("cdn.flowus.cn")) {
      referer = "https://flowus.cn/";
    }
    const res = yield request(url, {
      dataType: "arraybuffer",
      headers: {
        referer
      }
    });
    out_default.info("\u4E0B\u8F7D\u6210\u529F", url);
    return res.data;
  } catch (e) {
    out_default.warning(`\u4E0B\u8F7D\u5931\u8D25: ${url}\uFF0C${e.message}`);
    out_default.debug(e);
  }
});

// src/utils/package.ts
var _path = require('path'); var _path2 = _interopRequireDefault(_path);
var _fs = require('fs'); var _fs2 = _interopRequireDefault(_fs);
var resolvePackageExtPath = (pluginPath) => {
  const pluginLocalPath = _path2.default.resolve(process.cwd(), pluginPath);
  if (_fs2.default.existsSync(pluginLocalPath)) {
    return pluginLocalPath;
  } else {
    return pluginPath;
  }
};
var getPackage = (packageExt) => {
  try {
    if (typeof packageExt === "string") {
      out_default.warning("\u6CE8\u610F", `\u6B63\u5728\u4F7F\u7528\u63D2\u4EF6/\u62D3\u5C55\u70B9: ${packageExt}\uFF0C\u8BF7\u9075\u5FAA\u63D2\u4EF6/\u62D3\u5C55\u5F00\u53D1\u89C4\u8303`);
      const packageLocalPath = resolvePackageExtPath(packageExt);
      return __require(packageLocalPath);
    }
    if (typeof packageExt === "function") {
      out_default.warning("\u6CE8\u610F", `\u6B63\u5728\u4F7F\u7528\u63D2\u4EF6/\u62D3\u5C55\u70B9: ${packageExt.name}\uFF0C\u8BF7\u9075\u5FAA\u63D2\u4EF6/\u62D3\u5C55\u5F00\u53D1\u89C4\u8303`);
      return packageExt;
    }
    out_default.err("\u63D2\u4EF6/\u62D3\u5C55\u70B9\u914D\u7F6E\u6709\u8BEF\uFF0C\u8BF7\u68C0\u67E5");
    process.exit(1);
  } catch (e) {
    if (e.message.includes("Cannot find module")) {
      out_default.err("\u63D2\u4EF6/\u62D3\u5C55\u70B9\u914D\u7F6E\u6709\u8BEF\uFF0C\u8BF7\u68C0\u67E5");
    }
    process.exit(1);
  }
};

// src/utils/time.ts
var _dayjs = require('dayjs'); var _dayjs2 = _interopRequireDefault(_dayjs);
var _timezone = require('dayjs/plugin/timezone'); var _timezone2 = _interopRequireDefault(_timezone);
var _utc = require('dayjs/plugin/utc'); var _utc2 = _interopRequireDefault(_utc);
var _customParseFormat = require('dayjs/plugin/customParseFormat'); var _customParseFormat2 = _interopRequireDefault(_customParseFormat);
_dayjs2.default.extend(_utc2.default);
_dayjs2.default.extend(_timezone2.default);
_dayjs2.default.extend(_customParseFormat2.default);
var getTimes = (time) => {
  const timezone2 = process.env.TIME_ZONE || "Asia/Shanghai";
  if (typeof time === "string") {
    const hasTimezone = /[Zz]|[+-]\d{2}:\d{2}$/.test(time);
    if (hasTimezone) {
      return _dayjs2.default.call(void 0, time).valueOf();
    } else {
      return _dayjs2.default.tz(time, timezone2).valueOf();
    }
  }
  return _dayjs2.default.call(void 0, time).valueOf();
};
var timeFormat = (time) => {
  const timezone2 = process.env.TIME_ZONE || "Asia/Shanghai";
  const format = process.env.TIME_FORMAT || "YYYY-MM-DD HH:mm:ss";
  return _dayjs2.default.call(void 0, time).tz(timezone2).format(format);
};
var isTime = (time) => {
  return _dayjs2.default.call(void 0, time).isValid();
};






















exports.DocFail = DocFail; exports.HttpClientResponse = _urllib.HttpClientResponse; exports.ImageFail = ImageFail; exports.RequestOptions = _urllib.RequestOptions; exports.cleanParameter = cleanParameter; exports.delay = delay; exports.generateUniqueId = generateUniqueId; exports.getFileName = getFileName; exports.getFileType = getFileType; exports.getFileTypeFromBuffer = getFileTypeFromBuffer; exports.getFileTypeFromUrl = getFileTypeFromUrl; exports.getPackage = getPackage; exports.getPicBufferFromURL = getPicBufferFromURL; exports.getTimes = getTimes; exports.getUrl = getUrl; exports.getUrlListFromContent = getUrlListFromContent; exports.isTime = isTime; exports.out = out_default; exports.request = request; exports.resolvePackageExtPath = resolvePackageExtPath; exports.timeFormat = timeFormat;
//# sourceMappingURL=index.js.map